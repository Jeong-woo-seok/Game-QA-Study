# ISTQB CTFL 1장: 테스팅의 기초 요약 정리

**학습자: 정우석**

**학습일: 2025년 10월 28일**


## 1.1 테스팅이란?

테스팅은 단순히 '버그를 찾는 것'을 넘어, 소프트웨어의 품질 수준에 대한 정보를 이해관계자에게 제공하고, 결함 발견을 통해 리스크를 줄이는 모든 활동을 의미

### 1.1.1 테스트 목적

테스트의 목적은 상황에 따라 다르지만, 공통적으로 다음과 같은 목적을 가진다.

* 결함 발견: 테스트 대상의 결함(Defect)을 찾아내고, 장애(Failure)를 유발하는 조건을 식별

* 신뢰도 향상: 테스트 대상이 요구사항을 충족한다는 것에 대한 신뢰도 향상

* 정보 제공: 이해관계자가 품질 수준을 판단하고 의사결정을 내릴 수 있도록 충분한 정보를 제공

* 결함 예방: 개발 초기 단계부터 테스트 활동을 통해 요구사항이나 설계의 오류를 미리 발견하여 결함 자체를 예방

### 1.1.2 테스팅과 디버깅

신입 QA가 가장 명확하게 구분해야 할 개념

* 테스팅 (Testing): QA(테스터)의 주된 활동. 시스템을 실행하여 '예상 결과'와 '실제 결과'를 비교하고, '장애(Failure)'를 식별하는 활동

* 디버깅 (Debugging): 개발자(Developer)의 주된 활동. 테스팅을 통해 발견된 장애의 '근본 원인(Root Cause)'을 찾아 코드를 수정하고 '결함(Defect)'을 제거하는 활동

## 1.2 테스팅이 왜 필요한가?

테스팅은 소프트웨어 개발 생명 주기(SDLC)의 필수적인 부분이다.

### 1.2.3 오류, 결함, 장애, 그리고 근본 원인

이 4가지 용어의 인과 관계를 이해하는 것이 QA의 첫걸음

1. 오류 (Error / Mistake):

* "사람"*의 실수나 잘못된 판단. (e.g., 개발자가 요구사항을 잘못 이해함, 피로로 인해 오타를 냄)

2. 결함 (Defect / Bug / Fault):

* 오류의 결과로 "코드나 시스템" 속에 숨겨진 문제점. (e.g., '광고 시청 시 BGM이 꺼지지 않는' 로직)

3. 장애 (Failure):

* 숨어있던 결함이 "실행될 때" 시스템이 기대와 다르게 동작하는 "현상". (e.g., 유저가 실제로 BGM과 광고 소리가 겹치는 소음을 듣게 됨)

4. 근본 원인 (Root Cause):

* 이 모든 문제를 일으킨 최초의 원인. (e.g., "광고 재생 시 사운드 처리"에 대한 요구사항이 명세서에 없었음)

[인과 관계]
사람이 **오류(Error)**를 범하고 -> 코드에 **결함(Defect)**이 생기며 -> 이 코드가 실행될 때 유저가 **장애(Failure)**를 겪는다.

## 1.3 테스팅의 7가지 원리 

이 7가지 원칙은 QA로서 가져야 할 '철학'이자 '관점'이다.

### 원리 1: 테스팅은 결함의 존재를 밝힌다.

테스팅은 "버그가 있다"는 것을 증명할 수는 있지만, "버그가 더 이상 없다"는 것을 증명할 수는 없다.

(예: 내가 애니팡에서 버그 10개를 찾았다고 해서, 애니팡에 버그가 없다고 절대 말할 수 없다.)

### 원리 2: 완벽한 테스팅은 불가능하다.

모든 입력값과 모든 경로, 모든 환경의 조합을 테스트하는 것은 시간과 비용 문제로 불가능하다.

(예: 애니팡의 모든 스테이지를, 모든 아이템 조합으로, 지구상의 모든 폰 기종에서 테스트할 수는 없다.)

결론: 리스크와 우선순위에 기반한 **'선택과 집중'**이 필요하다. (e.g., '상점'처럼 돈과 직결되는 기능을 집중 테스트)

### 원리 3: 조기 테스팅이 시간과 비용을 절약한다.

개발 초기에(기획/설계 단계) 결함을 발견하면 수정 비용이 1이지만, 출시 직전에 발견하면 100이 들 수 있다.

(예: 코딩이 다 끝난 '주사위 이벤트'를 수정하는 것보다, 기획서 단계에서 '25분 걸리겠는데? 10회 기능 넣자'고 제안하는 것이 100배 싸다.)

### 원리 4: 결함은 집중된다.

소프트웨어 결함의 80%는 20%의 특정 모듈(기능)에 집중되어 있다. (파레토 법칙)

(예: 버그는 보통 '상점', '이벤트', '네트워크'처럼 복잡하고 자주 바뀌는 기능에 몰려있다.)

### 원리 5: 살충제 패러독스

매번 똑같은 살충제(테스트 케이스)만 뿌리면, 벌레(결함)들이 내성이 생겨 더 이상 잡히지 않는다.

결론: 테스트 케이스(TC)는 지속적으로 검토하고, 업데이트하고, 새로운 케이스를 추가해야 한다.

### 원리 6: 테스팅은 정황에 의존적이다.

테스트 방식은 소프트웨어의 특성(정황)에 따라 달라야 한다.

(예: '애니팡' 게임을 테스트하는 방식과 '은행 앱'을 테스트하는 방식은 리스크, 보안, 접근 방식이 완전히 달라야 한다.)

### 원리 7: '오류 부재의 궤변'

버그(결함)를 하나도 찾지 못했다고 해서 그 소프트웨어가 성공하는 것은 아니다.

(예: 버그는 하나도 없지만, 유저의 요구사항을 충족하지 못하거나 재미가 없다면 그 게임은 실패한 것이다. -> '주사위 이벤트'가 버그는 없지만 재미가 없는 것)

## 1.4 테스트 프로세스 

우리가 이전에 배운 STLC(Software Test Life Cycle)를 ISTQB는 7단계로 정의한다.

### 테스트 계획 : "어떻게 테스트할지" 전략 수립.

### 테스트 모니터링 및 제어 : 계획대로 잘 되고 있는지 추적하고, 벗어나면 조율.

### 테스트 분석 : "무엇을 테스트할지" 요구사항(기획서)을 분석하고 테스트 조건 식별.

### 테스트 설계 : "어떻게 테스트할지" 구체적인 테스트 케이스(TC) 작성.

### 테스트 구현 : TC를 실행할 환경과 데이터를 준비.

### 테스트 실행 : TC를 수행하고, '예상'과 '실제'를 비교하여 Pass/Fail 판정 및 버그 리포팅.

### 테스트 완료 : 테스트 결과 리포트를 작성하고, 학습한 내용을 정리.

1.5 테스팅의 심리학 

* QA의 마인드셋: 호기심, 비판적 시각, 세부 사항에 대한 관심, 개발자와의 긍정적인 커뮤니케이션.

* 결함 리포팅: 개발자를 '비난'하는 것이 아니라, "함께 품질을 높이기 위해" 객관적인 사실을 바탕으로 '결함'을 리포트해야 한다.
